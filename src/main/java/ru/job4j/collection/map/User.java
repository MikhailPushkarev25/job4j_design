package ru.job4j.collection.map;

import java.util.*;

public class User {

    private String name;
    private int children;
    private Calendar birthday;

    @Override
    public String toString() {
        return "User{" + "name='" + name + '\'' + ", children=" + children + ", birthday=" + birthday + '}';
    }

    public User(String name, int children, Calendar birthday) {
        this.name = name;
        this.children = children;
        this.birthday = birthday;

    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        User user = (User) o;
        return children == user.children && Objects.equals(name, user.name) && Objects.equals(birthday, user.birthday);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, children, birthday);
    }

    public static void main(String[] args) {
        User user = new User("Mikhail", 10, new GregorianCalendar(1995, 12, 5));
        User user1 = new User("Mikhail", 10, new GregorianCalendar(1995, 12, 5));

        Map<User, Object> one = new HashMap<>();
        one.put(user, "Mikhail");
        one.put(user1, "Mikhail");
        for (User val : one.keySet()) {
           System.out.println(val.toString());
        }

        System.out.println(user.hashCode() + " " + user1.hashCode());
    }
    /**
     * В классе я привожу пример работы HashMAp, на данный момент я создал модель
     * и метод main - в нем я определил два обьекта и создал мапу,
     * вывел два обьека на консоль и полученный результат получил по следующим причинам
     * 1 - сначала наш ключ проверяется на null,
     * генерируется хэш на основе ключа, для генерации используется hash(hashCode)
     * в который передается key.hashCode
     * по битовым сдвигам.
     * далее определяется позиция в массиве с помощью метода indexOf.
     * куда будет помещен результат.
     * Далее зная индекс в массиве, мы получаем список в массиве хэш и ключ поочередно сравнивается
     * в этом массиве при совпадении параметров, знчения элементов перезаписываются
     * если совпадений не выявлено, то добавится новый элемент.
     *
     * 2 - При переопределинии хэш кода,
     * для переопределения хешкода используется формула 31*поле*поле
     * далее хэш код у нас будет одинаковый, но eqalse - будет разный
     * далее добавляем зачение в карту,
     * индексы будут одни и те же, поэтому вставляем в следующую ячейку
     *
     * 3- При переопределении только Equals только равно -
     * в данном случае обьекты будут разные, так как
     * первый обьект будет в одной каорзине, а второй обьект
     * в другой корзине под разными индексами, поэтому результат чисел разный.
     *
     * 4 - При переопределинии и hashCode и equals
     * при hashcode будут идинаковые значения, при равенстве разные
     * мы попадаем в одну и ту же ячейку мапы, происходит перезатирание
     * длина составляет один
     *
     * 5 - Что такое коллизия
     * Коллизия - это когда хэш-код одинаковый, а объекты по равно разные.
     *
     * Разрешение коллизий происходит при помощи (цепочек). Каждая ячейка массива является указателем на связный список пар - ключ, значение.
     *
     * Соответствующим одному и тому же хэш значению ключа.
     *
     * Коллизии приводят к тому что цепочки длиной более одного элемента.
     *
     * 6 - как вычисляется функция
     *
     * static final int hash (ключ объекта) {
     *
     *     int h;
     *
     *     return (key == null)? 0: (h = key.hashCode ()) ^ (h >>> 16);
     *
     * }
     *
     * в методе hash () cначала вычисляется промежуточное значение h, оно равно хеш-функции от ключа (для HashMap в программе реализации Object.hashCode ()), вычисляется значение, равное нулевому значению побитовому сдвигу числа h вправо на 16 бит с заполнением нулями (> >> все биты числа сдвигаются вправо на 16 позиций, освободившиеся операции биты заполняются нулями), и для вычисленных выше значений выполняется XOR (^ побитовое логическое или).
     *
     *
     *
     * В методе коллекции, при поиске бакета / корзины / индекса хеш-код ключа делится с остатком (%) на размер хеш-таблицы (по умолчанию n = 16) и результатом будет число в диапазоне от 0 до n, т.е. номер ячейки в массиве, куда помещается объект с нашим ключом. А т.к. для HashMap размер хеш-таблицы равенство степени 2, то вместо% n (остаток от деления) используется более быстрый & (n-1) (побитовое И).
     *
     *
     *
     * Т.е. вместо index = hash% (n - 1) используется index = (n - 1) & hash
     *
     *
     *
     * Примечание: побитовый сдвиг >>> и операция XOR выполняются для того, чтобы старшие биты первоначального хеш-кода h продолжали участвовать в (n - 1) и хеширование даже при небольшом кол-ве бакетов. Этим обеспечьте себе наилучшее распределение в хеш-таблице, а страхуются от неудачной функции hashcode ().
     *
     *
     *
     * Итого: Через% или & вычисляется "внешний" хеш (находим бакет / индекс / индекс в массиве), через >>> "внутренний", который отвечает за усложение хеш-кода, подключая к формированию старшие биты.
     *
     *
     *
     *
     *
     *
     *
     * hashCode у объекта должен вычисляться на основании содержимого объекта (значения полей). При этом:
     *
     * - вызов метода hashCode один и более одного и того же объекта хэширования, при условии что поля объекта, участвующие в вычислении значения, не изменяются.
     *
     * - вызов метода hashCode над двумя объектами должен всегда возвращать одно и то же число, если эти объекты равны (вызов метода равен для этих объектов возвращает true).
     *
     * - вызов метода hashCode два неравных между собой объектами должен возвращать разные хэш-значения.
     *
     *
     *
     * Общепринятые правила при переопределении метода hashCode ():
     *
     * 1. Присвоить результирующую переменную (результат) некоторое ненулевое значение;
     *
     * 2. Если поле value имеет тип boolean, вычислить (значение? 0: 1);
     *
     * 3. Если значение поля имеет тип byte, char, short или int, вычислить (int) значение;
     *
     * 4. Если поле value имеет тип long, вычислить (int) (value - (value >>> 32));
     *
     * 5. Если поле value имеет тип float, вычислить Float.floatToIntBits (value);
     *
     * 6. Если значение поля имеет тип double, вычислите Double.doubleToLongBits (значение), а затем преобразовать полученное значение, как указано в п.4;
     *
     * 7. Если поле является ссылкой на объект, а метод equals данного класса сравнивает это поле, рекурсивно вызывая другие методы equals, так же рекурсивно вызвать для этого поля метод hashCode;
     *
     * 8. Если поле значение является ссылкой на объект и равно null, использовать число 0 для его представления хэш-кода;
     *
     * 9. Объединить полученное в п.2 - п.8 значения следующим образом: 31 * результат + значение;
     *
     * 10. Если поле является массивом, примените правило 9 для каждого элемента массива.
     *
     *
     *
     *
     */
}
